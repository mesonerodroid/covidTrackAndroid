Resumen así mas o menos de aplicación covid.


Primero, ver la api que hay, que con una sola llamada recupero todo. Creación de datos.

Después, investigación de retrofit con corutinas y work moderno. Desde hace poco, retrofit es compatible con ello, 
Tambien mire CourutineINfoWorker, que se podra usar para otras cosas. Pero retrofit 2.6 ya incluye todo lo necesario,

en el coviddtservice, el @GET es suspend fun getInfo(),  el repository se simplifica muchisimo, ahora solo tiene dos lineas: 
    var client: CovidDtService = createRetrofitWS()

    suspend fun getAllData() = client.getInfo()
	
ya no es necesario llamar a enqueue y crear callbacks.

LiveData’s building block already provides a Coroutine Scope where 

En el ViewModel, con el IO Dispatcher dado que vamos a llamar a una función de red. El viewmodel:

val obtData = liveData(Dispatchers.IO) {
    val infoResponse = repository.getAllData()

    emit(infoResponse)
}
	emit hace el seteo al livedata, que está creado en el viewmodel


Mas cosas por hacer:

-Los injections del viewModel (lo ultimo),
-guardar en room la info. si falla la llamada, mostrar ultimos datos.   ¿Llamar solo si la fecha es distinta a la almacenada? No, no interesa, por si actualizan.

XXX-ver como representar los datos, sin que haya que hacer nada en la activity.Dentro del fragment pintar los datos. En el fragmentXX  esto ASI A LO BRUTO ESTARIA

-Hacerlo bonito.
-mensaje si falla. Boton de recargar.
-fecha en pantalla



segundo día. Metiendo room, viendo claro que tiene que ser en el repositorio, si falla, donde pedir info a bbdd. Mirando todo los daos de room,
				 viendo que para ello va a ser necesario las injecciones (ahora estoy haciendo chapu y creando la base de 
					datos en la clase Application, porque para crearse necesita un contexto. El repositorio se crea en el viewmodel
						y claro no queremos tener contexto en viewmodel nunca. Entonces en el viewmodel cojo la db de Application.
	

siguientes dias. MIrando varias páginas, viendo como funciona hilt. Hay inyecciones diferenciasas.

1. Para la database, es necesario crear un DatabaseModule que incluya @module @installin y metodo con @provides para proporcionar el dao

2. La inyeccion del viewmodel. Para crear al mismo timpo el repositorio, que es lo gordo, estuve mas tiempo. Intente al principio inyectarlo. 
	Pero al final, con un ViewModelFactory, se puede inyectar el viewmodel instanciando en ese mismo momento la clase repositorio y lo que haga falta.
	Además aqui ya paso el dao inyectado en el fragmento, al repositorio para que pueda acceder a consultar los datos.
	Esto usando "by viewModels", hubo que meter dependencia por ahi, revisar gradle que fui metiendo bastantes cosas necesarias.
	ByViewmodels es extensión de extensiones KTX .
	
	-->NO hacía falta factory, con hilt ya no hacen falta nunca. Sí que pongo el inject basico en el repositorio, si no daria error.
		ademas en lo que he visto tiene un  @Assisted private val savedStateHandle: SavedStateHandle.  ESto es necesario anotar para la dependencia SavedStateHandle
	
3. Para la inyeccion basica, simplemente con un constructor vale.
		class CovidRepository @Inject constructor(dao: CovidDataDao) {

	
	

Ahora pienso seguir con los otros fragmentos. Creare otro viewmodel, aunque el objeto que use sea el mismo.... 	



en el segundo, uso el mismo viewmodel, ya que es la misma peticion, aunque podría crear otro.,
Creo un nuevo metodo en lugar de getAll, getCountryINfo o algo así.  El repositorio se va a encargar de obtener la información que se está solicitando,
sin pasar los datos globales, que aquí no son necesarios ni se tienen por qué conocer. Es decir, en este fragmento, sólo vamos a utilizar 
para mostrar los datos la clase DataCountryList (Clase del modelo del dominio, del domain model, no utilizo directamente los DTO de retrofit o de la 
base de datos, sino que están desacoplados de estos)

metido insercion de pais uno a uno.


falta el icono global countris e info,.
fatta algun remtae.
